// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
 LiquidShader.usf: Liquid shader for Zibra Liquids
 =============================================================================*/

#include "/Engine/Private/Common.ush"

/* Fluid parameters
=============================================================================*/

float4x4 ProjectionInverse;
float4x4 ViewMatrix;
float4x4 ViewProjectionInverse;
float4x4 Matrix_VP;
float3 ContainerScale;
float3 ContainerPosition;
float3 WorldSpaceCameraPos;
float3 GridSize;


/* Input resources
=============================================================================*/

//Texture2D Background;
//SamplerState BackgroundSampler;
//Texture2D CameraDepthTexture;
//SamplerState CameraDepthTextureSampler;

Texture2D LiquidColor;
SamplerState LiquidColorSampler;
StructuredBuffer<float4> GridNormal;

//Mesh Render
Texture2D Depth;
SamplerState DepthSampler;
Texture3D GridDensity;
SamplerState GridDensitySampler;
Texture3D GridNormalTexture;
SamplerState GridNormalSampler;

/* Helper functions
=============================================================================*/

// from UnityDeprecated.cginc

half DotClamped(half3 a, half3 b)
{
	return max(0.0h, dot(a, b));
}

half BlinnTerm(half3 normal, half3 halfDir)
{
	return DotClamped(normal, halfDir);
}
/*
============================================*/
float3 GetNodeF(float3 p)
{
	return (GridSize * (p - (ContainerPosition - ContainerScale * 0.5)) / ContainerScale);
}

int GetNodeID(float3 nodeIn)
{
	int3 node = int3(nodeIn);
	node = clamp(node, int3(0, 0, 0), int3(GridSize) - int3(1, 1, 1));
	return node.x + node.y * GridSize.x + node.z * GridSize.x * GridSize.y;
}

// Trilinear interpolation over grid
float4 TrilinearInterpolation(float3 p)
{
	float3 node = GetNodeF(p);
	
	float3 ni = floor(node);
	float3 nf = frac(node);

	//load the 8 node values
	float4 n000 = GridNormal[GetNodeID(ni + float3(0, 0, 0))];
	float4 n001 = GridNormal[GetNodeID(ni + float3(0, 0, 1))];
	float4 n010 = GridNormal[GetNodeID(ni + float3(0, 1, 0))];
	float4 n011 = GridNormal[GetNodeID(ni + float3(0, 1, 1))];
	float4 n100 = GridNormal[GetNodeID(ni + float3(1, 0, 0))];
	float4 n101 = GridNormal[GetNodeID(ni + float3(1, 0, 1))];
	float4 n110 = GridNormal[GetNodeID(ni + float3(1, 1, 0))];
	float4 n111 = GridNormal[GetNodeID(ni + float3(1, 1, 1))];

	//interpolate the node pairs along Z
	float4 n00 = lerp(n000, n001, nf.z);
	float4 n01 = lerp(n010, n011, nf.z);
	float4 n10 = lerp(n100, n101, nf.z);
	float4 n11 = lerp(n110, n111, nf.z);

	//interpolate the interpolated pairs along Y
	float4 n0 = lerp(n00, n01, nf.y);
	float4 n1 = lerp(n10, n11, nf.y);

	//interpolate the rest along X
	return lerp(n0, n1, nf.x);
}

float4 TransformFVector4(float4 fvector)
{
	return mul(fvector, ViewProjectionInverse);
}

/* Vertex shader
=============================================================================*/

void MainVS(
	in float4 InPosition : ATTRIBUTE0,
	in float2 InTexCoord : ATTRIBUTE1,
	out float4 OutPosition : SV_POSITION,
	out float2 OutUVAndScreenPos : TEXCOORD0,
	out float3 Raydir : TEXCOORD1
)
{
	OutPosition = InPosition;
	OutUVAndScreenPos = InTexCoord;
	
	float2 ScreenSpace = (InTexCoord * 2.0 - 1.0) * float2(1, -1);
	float4 RayStartProjectionSpace = float4(ScreenSpace, 1.0f, 1.0f);
	float4 RayEndProjectionSpace = float4(ScreenSpace, 0.5f, 1.0f);

	float4 HGRayEndWorldSpace = TransformFVector4(RayEndProjectionSpace);
	float3 RayEndWorldSpace = HGRayEndWorldSpace.xyz;
	
	float3 WorldOrigin = WorldSpaceCameraPos;

	if (HGRayEndWorldSpace.w != 0.0f)
	{
		RayEndWorldSpace /= HGRayEndWorldSpace.w;
	}
    
	Raydir = normalize(RayEndWorldSpace - WorldOrigin);
}

/* Pixel shader
=============================================================================*/

void MainPS(
	in float4 InPosition : POSITION,
	in float2 InTexCoord : TEXCOORD0,
	in float3 Raydir : TEXCOORD1,
	out float4 OutColor : SV_Target0,
	out float OutDepth : DEPTH
)
{
	float4 pos = Texture2DSample(LiquidColor, LiquidColorSampler, InTexCoord);
	float3 cameraPos = WorldSpaceCameraPos;
	float3 cameraRay = normalize(Raydir);
	float depth = pos.w;
	float3 newPos = cameraPos + cameraRay * depth;
	

	depth = depth / 10000.0f;
	
	if (depth > 0.0 && depth < 1e4) //has hit the liquid
	{	
		float4 f0 = TrilinearInterpolation(newPos.xyz);
		float3 normal = -normalize(f0.xyz);
		
		OutColor = float4(normal, depth);
		OutDepth = 1;
	}
	else
	{
		OutColor = float4(0, 0, 0, 1.0);
	}

	//Debug code
	//OutColor = float4(InPosition.x / 2048, InPosition.y / 2048, InPosition.zw);
	//OutColor = float4(Raydir, 0);
	//}
}


void MainMRPS(
	in float4 InPosition : POSITION,
	in float2 InTexCoord : TEXCOORD0,
	in float3 Raydir : TEXCOORD1,
	out float4 OutColor : SV_Target0,
	out float OutDepth : DEPTH
)
{
	//float4 pos = Texture2DSample(LiquidColor, LiquidColorSampler, InTexCoord);
	//float3 cameraPos = WorldSpaceCameraPos;
	//float3 cameraRay = normalize(Raydir);
	//float depth = pos.w;
	//float3 newPos = cameraPos + cameraRay * depth;
	

	//depth = depth / 10000.0f;
	
	//if (depth > 0.0 && depth < 1e4) //has hit the liquid
	//{
	//	float4 f0 = TrilinearInterpolation(newPos.xyz);
	//	float3 normal = -normalize(f0.xyz);
		
	//	OutColor = float4(normal, depth);
	//	OutDepth = 1;
	//}
	//else
	//{
	//	OutColor = float4(0, 0, 0, 1.0);
	//}
	OutColor = Texture2DSample(Depth, GridDensitySampler, InTexCoord);
	//OutColor = float4(1, 1, 0, 1.0);
	//Debug code
	//OutColor = float4(InPosition.x / 2048, InPosition.y / 2048, InPosition.zw);
	//OutColor = float4(Raydir, 0);
	//}
}